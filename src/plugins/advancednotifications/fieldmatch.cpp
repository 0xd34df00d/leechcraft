/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "fieldmatch.h"
#include <QtDebug>
#include <QDataStream>
#include "typedmatchers.h"

namespace LeechCraft
{
namespace AdvancedNotifications
{
	FieldMatch::FieldMatch ()
	: FieldType_ (QVariant::Invalid)
	{
	}

	FieldMatch::FieldMatch (QVariant::Type type)
	: FieldType_ (type)
	, Matcher_ (TypedMatcherBase::Create (type))
	{
	}

	FieldMatch::FieldMatch (QVariant::Type type,
			TypedMatcherBase_ptr matcher)
	: FieldType_ (type)
	, Matcher_ (matcher)
	{
	}

	QString FieldMatch::GetPluginID () const
	{
		return PluginID_;
	}

	void FieldMatch::SetPluginID (const QString& id)
	{
		PluginID_ = id;
	}

	QString FieldMatch::GetFieldName () const
	{
		return FieldName_;
	}

	void FieldMatch::SetFieldName (const QString& name)
	{
		FieldName_ = name;
	}

	QVariant::Type FieldMatch::GetType () const
	{
		return FieldType_;
	}

	void FieldMatch::SetType (QVariant::Type type)
	{
		FieldType_ = type;
		Matcher_ = TypedMatcherBase::Create (type);
	}

	TypedMatcherBase_ptr FieldMatch::GetMatcher () const
	{
		return Matcher_;
	}

	void FieldMatch::Save (QDataStream& out) const
	{
		out << static_cast<quint8> (1)
				<< PluginID_
				<< FieldName_
				<< FieldType_
				<< (Matcher_ ? Matcher_->Save () : QVariantMap ());
	}

	void FieldMatch::Load (QDataStream& in)
	{
		quint8 version = 0;
		in >> version;
		if (version != 1)
		{
			qWarning () << Q_FUNC_INFO
					<< "unknown version"
					<< version;
			return;
		}

		QVariantMap map;
		in >> PluginID_
			>> FieldName_
			>> FieldType_
			>> map;
		Matcher_ = TypedMatcherBase::Create (FieldType_);
		if (Matcher_)
			Matcher_->Load (map);
	}

	bool operator== (const FieldMatch& f1, const FieldMatch& f2)
	{
		return f1.GetType () == f2.GetType () &&
			f1.GetPluginID () == f2.GetPluginID () &&
			f1.GetFieldName () == f2.GetFieldName ();
	}
}
}
