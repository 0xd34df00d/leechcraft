/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "accountactionsmanager.h"
#include <QAction>
#include <QMenu>
#include <QInputDialog>
#include <QMessageBox>
#include <util/util.h>
#include <interfaces/core/icoreproxy.h>
#include "interfaces/azoth/iaccount.h"
#include "interfaces/azoth/imucjoinwidget.h"
#include "interfaces/azoth/iprotocol.h"
#include "interfaces/azoth/isupportbookmarks.h"
#include "interfaces/azoth/isupportactivity.h"
#include "interfaces/azoth/isupportmood.h"
#include "interfaces/azoth/isupportgeolocation.h"
#include "interfaces/azoth/ihaveservicediscovery.h"
#include "interfaces/azoth/ihaveconsole.h"
#include "interfaces/azoth/ihavemicroblogs.h"
#include "interfaces/azoth/iregmanagedaccount.h"
#include "interfaces/azoth/isupportnonroster.h"
#include "core.h"
#include "joinconferencedialog.h"
#include "bookmarksmanagerdialog.h"
#include "addcontactdialog.h"
#include "activitydialog.h"
#include "mooddialog.h"
#include "locationdialog.h"
#include "consolewidget.h"
#include "servicediscoverywidget.h"
#include "microblogstab.h"
#include "chattabsmanager.h"

namespace LeechCraft
{
namespace Azoth
{
	AccountActionsManager::AccountActionsManager (QWidget *mw, QObject *parent)
	: QObject (parent)
	, MW_ (mw)
	, AccountJoinConference_ (new QAction (tr ("Join conference..."), this))
	, AccountManageBookmarks_ (new QAction (tr ("Manage bookmarks..."), this))
	, AccountAddContact_ (new QAction (tr ("Add contact..."), this))
	, AccountOpenNonRosterChat_ (new QAction (tr ("Chat with non-CL contact"), this))
	, AccountViewMicroblogs_ (new QAction (tr ("View microblogs..."), this))
	, AccountSetActivity_ (new QAction (tr ("Set activity..."), this))
	, AccountSetMood_ (new QAction (tr ("Set mood..."), this))
	, AccountSetLocation_ (new QAction (tr ("Set location..."), this))
	, AccountSD_ (new QAction (tr ("Service discovery..."), this))
	, AccountConsole_ (new QAction (tr ("Console..."), this))
	, AccountUpdatePassword_ (new QAction (tr ("Update server password..."), this))
	, AccountRename_ (new QAction (tr ("Rename..."), this))
	, AccountModify_ (new QAction (tr ("Modify..."), this))
	{
		AccountJoinConference_->setProperty ("ActionIcon", "irc-join-channel");
		AccountManageBookmarks_->setProperty ("ActionIcon", "bookmarks-organize");
		AccountAddContact_->setProperty ("ActionIcon", "list-add-user");
		AccountSetMood_->setProperty ("ActionIcon", "face-smile");
		AccountSD_->setProperty ("ActionIcon", "services");
		AccountConsole_->setProperty ("ActionIcon", "utilities-terminal");
		AccountUpdatePassword_->setToolTip (tr ("Updates the account's password on the server"));
		AccountRename_->setProperty ("ActionIcon", "edit-rename");

		connect (AccountJoinConference_,
				SIGNAL (triggered ()),
				this,
				SLOT (joinAccountConference ()));
		connect (AccountManageBookmarks_,
				SIGNAL (triggered ()),
				this,
				SLOT (manageAccountBookmarks ()));
		connect (AccountAddContact_,
				SIGNAL (triggered ()),
				this,
				SLOT (addAccountContact ()));
		connect (AccountOpenNonRosterChat_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleOpenNonRoster ()));
		connect (AccountViewMicroblogs_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountMicroblogs ()));
		connect (AccountSetActivity_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountSetActivity ()));
		connect (AccountSetMood_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountSetMood ()));
		connect (AccountSetLocation_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountSetLocation ()));
		connect (AccountSD_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountSD()));
		connect (AccountConsole_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountConsole ()));
		connect (AccountUpdatePassword_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleUpdatePassword ()));
		connect (AccountRename_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountRename ()));
		connect (AccountModify_,
				SIGNAL (triggered ()),
				this,
				SLOT (handleAccountModify ()));
	}

	QList<QAction*> AccountActionsManager::GetMenuActions (QMenu *menu, QObject *accObj)
	{
		QList<QAction*> actions;

		IAccount *account = qobject_cast<IAccount*> (accObj);
		IProtocol *proto = qobject_cast<IProtocol*> (account->GetParentProtocol ());

		AccountJoinConference_->setEnabled (proto->GetFeatures () & IProtocol::PFMUCsJoinable);
		actions << AccountJoinConference_;

		if (qobject_cast<ISupportBookmarks*> (accObj))
		{
			auto supBms = qobject_cast<ISupportBookmarks*> (accObj);
			QVariantList bms = supBms->GetBookmarkedMUCs ();
			if (!bms.isEmpty ())
			{
				QMenu *bmsMenu = new QMenu (tr ("Join bookmarked conference"), menu);
				actions << bmsMenu->menuAction ();

				for (auto mucObj : qobject_cast<IAccount*> (accObj)->GetCLEntries ())
				{
					IMUCEntry *muc = qobject_cast<IMUCEntry*> (mucObj);
					if (!muc)
						continue;

					bms.removeAll (muc->GetIdentifyingData ());
				}

				for (const auto& bm : bms)
				{
					const QVariantMap& map = bm.toMap ();

					auto name = map ["StoredName"].toString ();
					const auto& hrName = map ["HumanReadableName"].toString ();
					if (name.isEmpty ())
						name = hrName;
					QAction *act = bmsMenu->addAction (name);
					act->setProperty ("Azoth/BMData", bm);
					act->setProperty ("Azoth/AccountObject", QVariant::fromValue<QObject*> (accObj));
					act->setToolTip (hrName);
					connect (act,
							SIGNAL (triggered ()),
							this,
							SLOT (joinAccountConfFromBM ()));
				}
			}

			actions << AccountManageBookmarks_;
		}
		actions << Util::CreateSeparator (menu);

		actions << AccountAddContact_;
		if (qobject_cast<ISupportNonRoster*> (accObj))
			actions << AccountOpenNonRosterChat_;
		actions << Util::CreateSeparator (menu);

		if (qobject_cast<IHaveMicroblogs*> (accObj))
		{
			actions << AccountViewMicroblogs_;
			actions << Util::CreateSeparator (menu);
		}

		if (qobject_cast<ISupportActivity*> (accObj))
			actions << AccountSetActivity_;
		if (qobject_cast<ISupportMood*> (accObj))
			actions << AccountSetMood_;
		if (qobject_cast<ISupportGeolocation*> (accObj))
			actions << AccountSetLocation_;
		actions << Util::CreateSeparator (menu);

		const auto& accActions = account->GetActions ();
		if (!accActions.isEmpty ())
		{
			actions += accActions;
			auto proxy = Core::Instance ().GetProxy ();
			for (auto action : actions)
				action->setIcon (proxy->GetIcon (action->property ("ActionIcon").toString ()));
			actions << Util::CreateSeparator (menu);
		}

		if (qobject_cast<IHaveServiceDiscovery*> (accObj))
			actions << AccountSD_;
		if (qobject_cast<IHaveConsole*> (accObj))
			actions << AccountConsole_;

		actions << Util::CreateSeparator (menu);

		if (auto managed = qobject_cast<IRegManagedAccount*> (account->GetQObject ()))
			if (managed->SupportsFeature (IRegManagedAccount::Feature::UpdatePass))
				actions << AccountUpdatePassword_;

		if (account->GetAccountFeatures () & IAccount::FRenamable)
			actions << AccountRename_;
		actions << AccountModify_;

		for (auto act : actions)
			act->setProperty ("Azoth/AccountObject",
					QVariant::fromValue<QObject*> (accObj));

		return actions;
	}

	namespace
	{
		IAccount* GetAccountFromSender (QObject *sender, const char *func)
		{
			if (!sender)
			{
				qWarning () << func
						<< "no sender";
				return 0;
			}

			const QVariant& objVar = sender->property ("Azoth/AccountObject");
			QObject *object = objVar.value<QObject*> ();
			if (!object)
			{
				qWarning () << func
						<< "no object in Azoth/AccountObject property of the sender"
						<< sender
						<< objVar;
				return 0;
			}

			IAccount *account = qobject_cast<IAccount*> (object);
			if (!account)
				qWarning () << func
						<< "object"
						<< object
						<< "could not be cast to IAccount";

			return account;
		}
	}

	void AccountActionsManager::joinAccountConference ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		QList<IAccount*> accounts;
		accounts << account;
		auto dia = new JoinConferenceDialog (accounts, MW_);
		dia->show ();
		dia->setAttribute (Qt::WA_DeleteOnClose, true);
	}

	void AccountActionsManager::joinAccountConfFromBM ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		const QVariant& bmData = sender ()->property ("Azoth/BMData");
		if (bmData.isNull ())
			return;

		IProtocol *proto = qobject_cast<IProtocol*> (account->GetParentProtocol ());

		auto jWidget = proto->GetMUCJoinWidget ();
		IMUCJoinWidget *imjw = qobject_cast<IMUCJoinWidget*> (jWidget);
		imjw->SetIdentifyingData (bmData.toMap ());
		imjw->Join (account->GetQObject ());

		jWidget->deleteLater ();
	}

	void AccountActionsManager::manageAccountBookmarks ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		auto dia = new BookmarksManagerDialog (MW_);
		dia->FocusOn (account);
		dia->show ();
	}

	void AccountActionsManager::addAccountContact ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		AddContactDialog dia (account, MW_);
		if (dia.exec () != QDialog::Accepted)
			return;

		dia.GetSelectedAccount ()->RequestAuth (dia.GetContactID (),
				dia.GetReason (), dia.GetNick (), dia.GetGroups ());
	}

	void AccountActionsManager::handleOpenNonRoster ()
	{
		const auto obj = sender ()->property ("Azoth/AccountObject").value<QObject*> ();
		const auto isnr = qobject_cast<ISupportNonRoster*> (obj);
		if (!isnr)
			return;

		QObject *entryObj = nullptr;
		QString contactId;
		while (!entryObj)
		{
			contactId = QInputDialog::getText (nullptr,
					tr ("Open chat with non-roster contact"),
					tr ("Enter ID of the contact you wish to open chat with:"),
					QLineEdit::Normal,
					contactId);
			if (contactId.isEmpty ())
				return;

			try
			{
				entryObj = isnr->CreateNonRosterItem (contactId);
			}
			catch (const std::exception& e)
			{
				QMessageBox::critical (nullptr,
						"LeechCraft Azoth",
						tr ("Error opening chat: %1")
							.arg (QString::fromUtf8 (e.what ())));
			}
		}

		const auto entry = qobject_cast<ICLEntry*> (entryObj);
		Core::Instance ().GetChatTabsManager ()->OpenChat (entry, true);
	}

	void AccountActionsManager::handleAccountMicroblogs ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		emit gotMicroblogsTab (new MicroblogsTab (account));
	}

	void AccountActionsManager::handleAccountSetActivity ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		QObject *obj = sender ()->property ("Azoth/AccountObject").value<QObject*> ();
		ISupportActivity *activity = qobject_cast<ISupportActivity*> (obj);
		if (!activity)
		{
			qWarning () << Q_FUNC_INFO
					<< obj
					<< "doesn't support activity";
			return;
		}

		ActivityDialog dia (MW_);
		if (dia.exec () != QDialog::Accepted)
			return;

		activity->SetActivity (dia.GetGeneral (), dia.GetSpecific (), dia.GetText ());
	}

	void AccountActionsManager::handleAccountSetMood ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		QObject *obj = sender ()->property ("Azoth/AccountObject").value<QObject*> ();
		ISupportMood *mood = qobject_cast<ISupportMood*> (obj);
		if (!mood)
		{
			qWarning () << Q_FUNC_INFO
					<< obj
					<< "doesn't support mood";
			return;
		}

		MoodDialog dia (MW_);
		if (dia.exec () != QDialog::Accepted)
			return;

		mood->SetMood (dia.GetMood (), dia.GetText ());
	}

	void AccountActionsManager::handleAccountSetLocation ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		QObject *obj = account->GetQObject ();
		ISupportGeolocation *loc = qobject_cast<ISupportGeolocation*> (obj);
		if (!loc)
		{
			qWarning () << Q_FUNC_INFO
					<< obj
					<< "doesn't support geolocation";
			return;
		}

		LocationDialog dia (MW_);
		if (dia.exec () != QDialog::Accepted)
			return;

		loc->SetGeolocationInfo (dia.GetInfo ());
	}

	void AccountActionsManager::handleAccountSD ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		auto w = new ServiceDiscoveryWidget ();
		w->SetAccount (account->GetQObject ());
		emit gotSDWidget (w);
	}

	void AccountActionsManager::handleAccountConsole ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		if (!Account2CW_.contains (account))
		{
			ConsoleWidget *cw = new ConsoleWidget (account->GetQObject ());
			Account2CW_ [account] = cw;
			connect (cw,
					SIGNAL (removeTab (QWidget*)),
					this,
					SLOT (consoleRemoved (QWidget*)));
		}

		emit gotConsoleWidget (Account2CW_ [account]);
	}

	void AccountActionsManager::handleUpdatePassword ()
	{
		auto account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		const auto& name = account->GetAccountName ();
		const auto& pass = QInputDialog::getText (0,
				tr ("Change password"),
				tr ("Enter new password for account %1 (the password will be updated on server):")
					.arg (name),
				QLineEdit::Password);
		if (pass.isEmpty ())
			return;

		auto managed = qobject_cast<IRegManagedAccount*> (account->GetQObject ());
		managed->UpdateServerPassword (pass);
	}

	void AccountActionsManager::handleAccountRename ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		const QString& name = account->GetAccountName ();
		const QString& newName = QInputDialog::getText (0,
				tr ("Rename account"),
				tr ("Enter new name for account %1:")
					.arg (name),
				QLineEdit::Normal,
				name);
		if (newName.isEmpty ())
			return;

		account->RenameAccount (newName);
	}

	void AccountActionsManager::handleAccountModify ()
	{
		IAccount *account = GetAccountFromSender (sender (), Q_FUNC_INFO);
		if (!account)
			return;

		account->OpenConfigurationDialog ();
	}

	void AccountActionsManager::consoleRemoved (QWidget *w)
	{
		ConsoleWidget *cw = qobject_cast<ConsoleWidget*> (w);
		Account2CW_.remove (Account2CW_.key (cw));
	}
}
}
