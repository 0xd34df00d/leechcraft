/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "kbctl.h"
#include <QtDebug>
#include <QTimer>
#include <QProcess>
#include <QCoreApplication>
#include <util/x11/xwrapper.h>
#include "xmlsettingsmanager.h"
#include "rulesstorage.h"

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/XKBlib.h>

namespace LeechCraft
{
namespace KBSwitch
{
	namespace
	{
		bool EvFilter (void *msg)
		{
			return KBCtl::Instance ().Filter (static_cast<XEvent*> (msg));
		}
	}

	KBCtl::KBCtl ()
	: PrevFilter_ (QAbstractEventDispatcher::instance ()->setEventFilter (EvFilter))
	{
		InitDisplay ();

		Rules_ = new RulesStorage (Display_);

		XWindowAttributes wa;
		XGetWindowAttributes (Display_, Window_, &wa);
		const auto rootEvents = StructureNotifyMask |
				SubstructureNotifyMask |
				PropertyChangeMask |
				FocusChangeMask |
				KeymapStateMask |
				LeaveWindowMask |
				EnterWindowMask;
		XSelectInput (Display_, Window_, wa.your_event_mask | rootEvents);

		XkbSelectEventDetails (Display_, XkbUseCoreKbd,
				XkbStateNotify, XkbAllStateComponentsMask, XkbGroupStateMask);

		CheckExtWM ();

		if (!ExtWM_)
			SetupNonExtListeners ();

		UpdateGroupNames ();

		QSettings settings (QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_KBSwitch");
		settings.beginGroup ("Groups");
		auto enabledGroups = settings.childKeys ();
		if (!enabledGroups.isEmpty ())
		{
			Variants_.clear ();
			for (const auto& group : enabledGroups)
				Variants_ [group] = settings.value (group).toString ();

			SetEnabledGroups (enabledGroups);
		}
		settings.endGroup ();

		XmlSettingsManager::Instance ().RegisterObject ({
					"ManageSystemWide",
					"KeyboardModel",
					"ManageKeyRepeat",
					"RepeatRate",
					"RepeatTimeout"
				},
				this, "scheduleApply");
	}

	KBCtl& KBCtl::Instance ()
	{
		static KBCtl ctl;
		return ctl;
	}

	void KBCtl::Release ()
	{
		XCloseDisplay (Display_);
	}

	void KBCtl::SetSwitchPolicy (SwitchPolicy policy)
	{
		Policy_ = policy;
	}

	int KBCtl::GetCurrentGroup () const
	{
		XkbStateRec state;
		XkbGetState (Display_, XkbUseCoreKbd, &state);
		return state.group;
	}

	const QStringList& KBCtl::GetEnabledGroups () const
	{
		return Groups_;
	}

	void KBCtl::SetEnabledGroups (QStringList groups)
	{
		if (groups.contains ("us") && groups.at (0) != "us")
		{
			groups.removeAll ("us");
			groups.prepend ("us");
		}

		if (Groups_ == groups)
			return;

		Groups_ = groups;
		scheduleApply ();
	}

	QString KBCtl::GetGroupVariant (const QString& group) const
	{
		return Variants_ [group];
	}

	void KBCtl::SetGroupVariants (const QHash<QString, QString>& variants)
	{
		Variants_ = variants;
		for (auto i = Variants_.begin (); i != Variants_.end (); )
		{
			if (i->isEmpty ())
				i = Variants_.erase (i);
			else
				++i;
		}

		scheduleApply ();
	}

	int KBCtl::GetMaxEnabledGroups () const
	{
		return XkbNumKbdGroups;
	}

	QString KBCtl::GetLayoutName (int group) const
	{
		return Groups_.value (group);
	}

	QString KBCtl::GetLayoutDesc (int group) const
	{
		return Rules_->GetLayoutsN2D () [GetLayoutName (group)];
	}

	void KBCtl::SetOptions (const QStringList& opts)
	{
		if (Options_ == opts)
			return;

		Options_ = opts;
		Options_.sort ();
		scheduleApply ();
	}

	const RulesStorage* KBCtl::GetRulesStorage () const
	{
		return Rules_;
	}

	bool KBCtl::Filter (XEvent *event)
	{
		auto invokePrev = [this, event] { return PrevFilter_ ? PrevFilter_ (event) : false; };

		if (event->type == XkbEventType_)
		{
			HandleXkbEvent (event);
			return invokePrev ();
		}

		switch (event->type)
		{
		case FocusIn:
		case FocusOut:
		case PropertyNotify:
			SetWindowLayout (Util::XWrapper::Instance ().GetActiveApp ());
			break;
		case CreateNotify:
		{
			const auto window = event->xcreatewindow.window;
			AssignWindow (window);
			break;
		}
		case DestroyNotify:
			Win2Group_.remove (event->xdestroywindow.window);
			break;
		}

		return invokePrev ();
	}

	void KBCtl::HandleXkbEvent (XEvent *event)
	{
		XkbEvent xkbEv;
		xkbEv.core = *event;

		switch (xkbEv.any.xkb_type)
		{
		case XkbStateNotify:
			if (xkbEv.state.group == xkbEv.state.locked_group)
				Win2Group_ [Util::XWrapper::Instance ().GetActiveApp ()] = xkbEv.state.group;
			emit groupChanged (xkbEv.state.group);
			break;
		case XkbNewKeyboardNotify:
			Win2Group_.clear ();
			UpdateGroupNames ();
			break;
		default:
			break;
		}
	}

	void KBCtl::SetWindowLayout (Qt::HANDLE window)
	{
		if (Policy_ != SwitchPolicy::PerWindow)
			return;

		if (window == None)
			return;

		if (!Win2Group_.contains (window))
			return;

		const auto group = Win2Group_ [window];
		XkbLockGroup (Display_, XkbUseCoreKbd, group);
	}

	void KBCtl::InitDisplay ()
	{
		int xkbError, xkbReason;
		int mjr = XkbMajorVersion, mnr = XkbMinorVersion;
		Display_ = XkbOpenDisplay (nullptr,
				&XkbEventType_,
				&xkbError,
				&mjr,
				&mnr,
				&xkbReason);
		Window_ = DefaultRootWindow (Display_);

		NetActiveWinAtom_ = Util::XWrapper::Instance ().GetAtom ("_NET_ACTIVE_WINDOW");
	}

	void KBCtl::CheckExtWM ()
	{
		Atom type;
		int format;
		uchar *prop = nullptr;
		ulong count, after;
		const auto ret = XGetWindowProperty (Display_, Window_, NetActiveWinAtom_,
				0, sizeof (Window), 0, XA_WINDOW,
				&type, &format, &count, &after, &prop);
		if (ret == Success && prop)
		{
			XFree (prop);
			ExtWM_ = true;
		}
		else
			qWarning () << Q_FUNC_INFO
					<< "extended window manager hints support wasn't detected, this won't work";
	}

	void KBCtl::SetupNonExtListeners ()
	{
		uint count = 0;
		Window d1, d2;
		Window *windows = nullptr;

		if (!XQueryTree (Display_, Window_, &d1, &d2, &windows, &count))
			return;

		for (uint i = 0; i < count; ++i)
			AssignWindow (windows [i]);

		if (windows)
			XFree (windows);
	}

	void KBCtl::UpdateGroupNames ()
	{
		auto desc = XkbAllocKeyboard ();
		XkbGetControls (Display_, XkbAllControlsMask, desc);
		XkbGetNames (Display_, XkbSymbolsNameMask | XkbGroupNamesMask, desc);

		if (!desc->names || !desc->names->groups)
		{
			qWarning () << Q_FUNC_INFO
					<< "cannot get names";
			return;
		}

		Groups_.clear ();

		const auto group = desc->names->groups;
		size_t groupCount = 0;
		for (; groupCount < XkbNumKbdGroups && group [groupCount]; ++groupCount) ;

		char **result = new char* [groupCount];
		XGetAtomNames (Display_, group, groupCount, result);

		const auto& layoutsD2N = Rules_->GetLayoutsD2N ();
		const auto& varredLayouts = Rules_->GetVariantsD2Layouts ();
		for (size_t i = 0; i < groupCount; ++i)
		{
			const QString str (result [i]);
			XFree (result [i]);

			if (!layoutsD2N [str].isEmpty ())
			{
				const auto& grp = layoutsD2N [str];
				Groups_ << grp;
				Variants_.remove (grp);
			}
			else if (!varredLayouts [str].first.isEmpty ())
			{
				const auto& grp = varredLayouts [str];
				Groups_ << grp.first;
				Variants_ [grp.first] = grp.second;
			}
			else
			{
				qWarning () << Q_FUNC_INFO
						<< str
						<< "not present anywhere";
				qWarning () << varredLayouts.contains (str);
				continue;
			}
		}
		delete [] result;

		XkbFreeNames (desc, XkbSymbolsNameMask | XkbGroupNamesMask, True);

		qDebug () << Q_FUNC_INFO << Groups_;
	}

	void KBCtl::AssignWindow (Qt::HANDLE window)
	{
		if (ExtWM_)
			return;

		XWindowAttributes wa;
		if (!XGetWindowAttributes (Display_, window, &wa))
			return;

		const auto windowEvents = EnterWindowMask |
				FocusChangeMask |
				PropertyChangeMask |
				StructureNotifyMask;
		XSelectInput (Display_, window, windowEvents);
	}

	void KBCtl::scheduleApply ()
	{
		if (ApplyScheduled_)
			return;

		ApplyScheduled_ = true;
		QTimer::singleShot (100,
				this,
				SLOT (apply ()));
	}

	void KBCtl::ApplyKeyRepeat ()
	{
		if (!XmlSettingsManager::Instance ().property ("ManageKeyRepeat").toBool ())
			return;

		XkbChangeEnabledControls (Display_, XkbUseCoreKbd, XkbRepeatKeysMask, XkbRepeatKeysMask);

		auto timeout = XmlSettingsManager::Instance ().property ("RepeatTimeout").toUInt ();
		auto rate = XmlSettingsManager::Instance ().property ("RepeatRate").toUInt ();
		XkbSetAutoRepeatRate (Display_, XkbUseCoreKbd, timeout, 1000 / rate);

		// X11 is crap, XkbSetAutoRepeatRate() doesn't work next time if we don't call this.
		XkbGetAutoRepeatRate (Display_, XkbUseCoreKbd, &timeout, &rate);
	}

	void KBCtl::apply ()
	{
		ApplyScheduled_ = false;

		QSettings settings (QCoreApplication::organizationName (),
				QCoreApplication::applicationName () + "_KBSwitch");
		settings.beginGroup ("Groups");
		settings.remove ("");
		for (const auto& group : Groups_)
			settings.setValue (group, Variants_.value (group));
		settings.endGroup ();

		if (!XmlSettingsManager::Instance ()
				.property ("ManageSystemWide").toBool ())
			return;

		auto kbModel = XmlSettingsManager::Instance ()
				.property ("KeyboardModel").toString ();
		const auto& kbCode = Rules_->GetKBModelCode (kbModel);

		QStringList args
		{
			"-layout",
			Groups_.join (","),
			"-model",
			kbCode,
			"-option"
		};

		if (!Options_.isEmpty ())
			args << "-option"
					<< Options_.join (",");

		if (!Variants_.isEmpty ())
		{
			QStringList variants;
			for (const auto& group : Groups_)
				variants << Variants_.value (group);
			args << "-variant"
					<< variants.join (",");
		}

		qDebug () << Q_FUNC_INFO << args;
		QProcess::startDetached ("setxkbmap", args);

		ApplyKeyRepeat ();
	}
}
}
