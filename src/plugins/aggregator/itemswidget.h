/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#pragma once

#include <QWidget>
#include "ui_itemswidget.h"
#include "item.h"
#include "channel.h"

class QModelIndex;
class QToolBar;
class IWebBrowser;
class QSortFilterProxyModel;

namespace LeechCraft
{
namespace Aggregator
{
	struct ItemsWidget_Impl;
	struct ChannelActions;
	struct AppWideActions;
	class Aggregator;
	class ItemsFilterModel;

	class ItemsWidget : public QWidget
	{
		Q_OBJECT

		friend class Aggregator;
		ItemsWidget_Impl *Impl_;
	public:
		enum class Action
		{
			MarkAsRead,
			MarkAsUnread,
			MarkAsImportant,
			PrevUnreadItem,
			PrevItem,
			NextItem,
			NextUnreadItem,
			Delete,

			MaxAction
		};

		ItemsWidget (QWidget* = 0);
		virtual ~ItemsWidget ();

		void SetAppWideActions (const AppWideActions&);
		void SetChannelActions (const ChannelActions&);
		void SetChannelsFilter (QSortFilterProxyModel*);

		void RegisterShortcuts ();

		Item_ptr GetItem (const QModelIndex&) const;
		QToolBar* GetToolBar () const;
		void SetTapeMode (bool);

		QAction* GetAction (Action) const;

		/** Merge all that channels that are currently shown.
			*
			* @param[in] on Whether the merge mode should be enabled.
			*/
		void SetMergeMode (bool on);

		/** Merge only those channels that match given tags.
			*
			* To disable the merge mode enabled by this, either enable
			* "usual" merge mode via SetMergeMode() or do a
			* CurrentChannelChanged().
			*
			* If "usual" merge mode (as activated by SetMergeMode())
			* is currently active, this function does nothing.
			*
			* @param[in] tags The list of tags to merge.
			*/
		void SetMergeModeTags (const QStringList& tags);
		void SetHideRead (bool);
		bool IsItemCurrent (int) const;
		void Selected (const QModelIndex&);
		void MarkItemReadStatus (const QModelIndex&, bool);
		bool IsItemRead (int) const;
		bool IsItemReadNotCurrent (int) const;
		QStringList GetItemCategories (int) const;
		IDType_t GetItemIDFromRow (int) const;
		void SubscribeToComments (const QModelIndex&) const;
		void CurrentChannelChanged (const QModelIndex&);

		void ConstructBrowser ();
		void LoadUIState ();
		void SaveUIState ();
	private:
		void ClearSupplementaryModels ();
		void AddSupplementaryModelFor (const ChannelShort&);
		void SetupActions ();
		QToolBar* SetupToolBar ();
		QString GetHex (QPalette::ColorRole,
				QPalette::ColorGroup = QApplication::palette ().currentColorGroup ());
		QString ToHtml (const Item_ptr&);
		void RestoreSplitter ();
		QModelIndexList GetSelected () const;
	public slots:
		void handleItemDataUpdated (Item_ptr, Channel_ptr);
	private slots:
		void invalidateMergeMode ();
		void on_ActionHideReadItems__triggered ();
		void on_ActionShowAsTape__triggered ();
		void on_ActionMarkItemAsUnread__triggered ();
		void on_ActionMarkItemAsRead__triggered ();
		void on_ActionMarkItemAsImportant__triggered ();
		void on_ActionDeleteItem__triggered ();

		void on_ActionPrevUnreadItem__triggered ();
		void on_ActionPrevItem__triggered ();
		void on_ActionNextItem__triggered ();
		void on_ActionNextUnreadItem__triggered ();

		void on_CaseSensitiveSearch__stateChanged (int);
		void on_ActionItemCommentsSubscribe__triggered ();
		void on_ActionItemLinkOpen__triggered ();
		void on_CategoriesSplitter__splitterMoved ();
		void currentItemChanged ();
		void checkSelected ();
		void makeCurrentItemVisible ();
		void updateItemsFilter ();
		void selectorVisiblityChanged ();
		void navBarVisibilityChanged ();
	signals:
		void movedToChannel (const QModelIndex&);
	};
}
}
