/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2014  Georg Rudoy
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "thumbswidget.h"
#include <QtDebug>
#include "pageslayoutmanager.h"
#include "pagegraphicsitem.h"
#include "smoothscroller.h"
#include "common.h"

namespace LeechCraft
{
namespace Monocle
{
	ThumbsWidget::ThumbsWidget (QWidget *parent)
	: QWidget (parent)
	{
		Ui_.setupUi (this);
		Ui_.ThumbsView_->setScene (&Scene_);
		Ui_.ThumbsView_->setBackgroundBrush (palette ().brush (QPalette::Dark));

		auto scroller = new SmoothScroller { Ui_.ThumbsView_, this };

		LayoutMgr_ = new PagesLayoutManager (Ui_.ThumbsView_, scroller, this);
		LayoutMgr_->SetScaleMode (ScaleMode::FitWidth);
		LayoutMgr_->SetMargins (10, 0);

		connect (LayoutMgr_,
				SIGNAL (scheduledRelayoutFinished ()),
				this,
				SLOT (handleRelayouted ()));
	}

	void ThumbsWidget::HandleDoc (IDocument_ptr doc)
	{
		Scene_.clear ();
		CurrentAreaRects_.clear ();
		CurrentDoc_ = doc;

		if (!doc)
			return;

		QList<PageGraphicsItem*> pages;
		for (int i = 0, size = CurrentDoc_->GetNumPages (); i < size; ++i)
		{
			auto item = new PageGraphicsItem (CurrentDoc_, i);
			Scene_.addItem (item);
			item->SetReleaseHandler ([this] (int page, const QPointF&) { emit pageClicked (page); });
			pages << item;
		}

		LayoutMgr_->HandleDoc (CurrentDoc_, pages);
		LayoutMgr_->Relayout ();
	}

	void ThumbsWidget::updatePagesVisibility (const QMap<int, QRect>& page2rect)
	{
		LastVisibleAreas_ = page2rect;

		if (page2rect.size () != CurrentAreaRects_.size ())
		{
			for (auto rect : CurrentAreaRects_)
			{
				Scene_.removeItem (rect);
				delete rect;
			}
			CurrentAreaRects_.clear ();

			const auto& brush = palette ().brush (QPalette::Dark);
			for (int i = 0; i < page2rect.size (); ++i)
			{
				auto item = Scene_.addRect ({}, { Qt::black }, brush);
				item->setZValue (1);
				item->setOpacity (0.3);
				CurrentAreaRects_ << item;
			}
		}

		const auto& pages = LayoutMgr_->GetPages ();

		int rectIdx = 0;
		for (auto i = page2rect.begin (); i != page2rect.end (); ++i, ++rectIdx)
		{
			const auto pageNum = i.key ();
			if (pageNum >= pages.size ())
				continue;

			auto page = pages.at (pageNum);

			const auto& docRect = *i;
			const auto& sceneRect = page->mapToScene (page->MapFromDoc (docRect)).boundingRect ();
			CurrentAreaRects_ [rectIdx]->setRect (sceneRect);
		}
	}

	void ThumbsWidget::handleCurrentPage (int page)
	{
		LayoutMgr_->SetCurrentPage (page, false);
	}

	void ThumbsWidget::handleRelayouted ()
	{
		updatePagesVisibility (LastVisibleAreas_);
	}
}
}

